<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Collision Chain-Reaction Balls</title>
<style>
  body {
    margin: 0;
    background: #020617;
    overflow: hidden;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  }
  canvas { display: block; }

  #highscorePanel {
    position: fixed;
    right: 12px;
    top: 10px;
    color: white;
    padding: 8px 14px;
    background: rgba(255,255,255,0.1);
    border-radius: 8px;
    font-size: 14px;
    line-height: 18px;
    pointer-events: none;
    white-space: nowrap;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="highscorePanel"></div>

<script>
/* ----------------------------------------------------------
   CRASH-PERSISTENT HIGH SCORE SYSTEM
-----------------------------------------------------------*/
function loadJSON(key, fallback) {
  try { return JSON.parse(localStorage.getItem(key)) || fallback; }
  catch { return fallback; }
}

let lastState = loadJSON("chainBalls_lastState", null);
let highScore = loadJSON("chainBalls_highScore", {
  maxBalls: 0,
  fps: 0,
  timestamp: null
});

const now = Date.now();
const CRASH_THRESHOLD_MS = 3000;

// REAL crash detection (no timer fired for 3+ seconds)
if (lastState && now - lastState.timestamp > CRASH_THRESHOLD_MS) {
  if (lastState.balls > highScore.maxBalls) {
    highScore = {
      maxBalls: lastState.balls,
      fps: lastState.fps,
      timestamp: new Date(lastState.timestamp).toLocaleString()
    };
    localStorage.setItem("chainBalls_highScore", JSON.stringify(highScore));
  }
}

// reset state for new session
localStorage.setItem("chainBalls_lastState", JSON.stringify({
  balls: 0, fps: 0, timestamp: Date.now()
}));

/* ----------------------------------------------------------
   CANVAS + WORLD SETUP
-----------------------------------------------------------*/
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
resize();
addEventListener("resize", resize);

const INITIAL_BALLS = 20;
const BALL_RADIUS = 7;
const BASE_SPEED = 2.4;
const TRAIL_FADE = 0.15;
const SPAWN_COOLDOWN_FRAMES = 3;

function randRange(a,b){ return a + Math.random()*(b-a); }
function randomColor(){ return `hsl(${Math.random()*360},80%,60%)`; }

/* ----------------------------------------------------------
   BALL CLASS
-----------------------------------------------------------*/
class Ball {
  constructor(x, y, vx, vy, r, color) {
    this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.r=r;
    this.color=color; this.lastSpawnFrame=-9999;
  }
  update(){
    this.x+=this.vx; this.y+=this.vy;

    if(this.x-this.r<0){ this.x=this.r; this.vx*=-1; }
    else if(this.x+this.r>canvas.width){ this.x=canvas.width-this.r; this.vx*=-1; }
    if(this.y-this.r<0){ this.y=this.r; this.vy*=-1; }
    else if(this.y+this.r>canvas.height){ this.y=canvas.height-this.r; this.vy*=-1; }
  }
  draw(){
    ctx.fillStyle=this.color;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
    ctx.fill();
  }
}

/* ----------------------------------------------------------
   SPAWN STARTER BALLS
-----------------------------------------------------------*/
let balls = [];
for(let i=0;i<INITIAL_BALLS;i++) balls.push(createRandomBall());

function createRandomBall(){
  const ang=Math.random()*Math.PI*2;
  const sp=randRange(BASE_SPEED*0.5,BASE_SPEED*1.5);
  return new Ball(
    randRange(BALL_RADIUS*4, canvas.width - BALL_RADIUS*4),
    randRange(BALL_RADIUS*4, canvas.height - BALL_RADIUS*4),
    Math.cos(ang)*sp,
    Math.sin(ang)*sp,
    BALL_RADIUS,
    randomColor()
  );
}

/* ----------------------------------------------------------
   COLLISION RESOLUTION
-----------------------------------------------------------*/
function distSq(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

function resolveCollision(b1,b2){
  const dx=b2.x-b1.x, dy=b2.y-b1.y;
  const dist=Math.hypot(dx,dy) || 1;
  const overlap=(b1.r+b2.r)-dist;

  if(overlap>0){
    const nx=dx/dist, ny=dy/dist;
    const half=overlap/2;

    b1.x-=nx*half; b1.y-=ny*half;
    b2.x+=nx*half; b2.y+=ny*half;

    const v1n=b1.vx*nx + b1.vy*ny;
    const v2n=b2.vx*nx + b2.vy*ny;
    const v1t=-b1.vx*ny + b1.vy*nx;
    const v2t=-b2.vx*ny + b2.vy*nx;

    const v1nA=v2n, v2nA=v1n;

    b1.vx=v1nA*nx - v1t*ny;
    b1.vy=v1nA*ny + v1t*nx;
    b2.vx=v2nA*nx - v2t*ny;
    b2.vy=v2nA*ny + v2t*nx;
  }
}

/* ----------------------------------------------------------
   GLOBAL SPAWN LIMITER + SAFE SPAWN POSITION
-----------------------------------------------------------*/
let frame = 0;
let globalSpawnFrame = 0;

/* ----------------------------------------------------------
   STATE SAVING (REAL CRASH DETECTION)
-----------------------------------------------------------*/
let fps = 60;
let lastFrameTime = performance.now();

function saveState() {
  localStorage.setItem("chainBalls_lastState", JSON.stringify({
    balls: balls.length,
    fps: fps,
    timestamp: Date.now()
  }));
}
setInterval(saveState, 1000);

/* ----------------------------------------------------------
   HIGH SCORE HUD
-----------------------------------------------------------*/
function updateHighScoreHUD() {
  document.getElementById("highscorePanel").innerHTML =
    `High Score: <b>${highScore.maxBalls}</b><br>` +
    `FPS at Crash: <b>${highScore.fps.toFixed(1)}</b><br>` +
    `When: ${highScore.timestamp || "â€”"}`;
}

/* ----------------------------------------------------------
   MAIN LOOP
-----------------------------------------------------------*/
function animate(now){
  frame++;

  const dt = now - lastFrameTime;
  fps = fps * 0.9 + (1000/dt)*0.1;
  lastFrameTime = now;

  requestAnimationFrame(animate);

  ctx.fillStyle = `rgba(2,6,23,${TRAIL_FADE})`;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const newBalls = [];
  const rr = (BALL_RADIUS*2)**2;
  const len = balls.length;

  for(const b of balls) b.update();

  for(let i=0;i<len;i++){
    for(let j=i+1;j<len;j++){
      const b1=balls[i], b2=balls[j];
      if(distSq(b1,b2)<=rr){

        resolveCollision(b1,b2);

        // GLOBAL COOL DOWN: spawns at most 1 every 2 frames
        if(frame - globalSpawnFrame >= 2 &&
           frame > b1.lastSpawnFrame + SPAWN_COOLDOWN_FRAMES &&
           frame > b2.lastSpawnFrame + SPAWN_COOLDOWN_FRAMES){

          globalSpawnFrame = frame;

          const dx = b2.x - b1.x;
          const dy = b2.y - b1.y;
          const dist = Math.hypot(dx, dy) || 1;

          const nx = dx / dist;
          const ny = dy / dist;

          // SAFE spawn outside collision area
          const spawnDist = BALL_RADIUS * 2.5;
          const mx = b1.x + nx * spawnDist;
          const my = b1.y + ny * spawnDist;

          const angle = Math.random() * Math.PI * 2;
          const speed = randRange(BASE_SPEED * 0.8, BASE_SPEED * 2.0);

          const nb = new Ball(
            mx, my,
            Math.cos(angle)*speed,
            Math.sin(angle)*speed,
            BALL_RADIUS,
            randomColor()
          );

          b1.lastSpawnFrame = frame;
          b2.lastSpawnFrame = frame;

          newBalls.push(nb);
        }
      }
    }
  }

  balls.push(...newBalls);

  for(const b of balls) b.draw();

  ctx.fillStyle="rgba(255,255,255,0.9)";
  ctx.font="14px system-ui";
  ctx.fillText(`Balls: ${balls.length}`,12,10);
  ctx.fillText(`FPS: ${fps.toFixed(1)}`,12,28);

  updateHighScoreHUD();
}

requestAnimationFrame(animate);
</script>
</body>
</html>
