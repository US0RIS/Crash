<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Collision Chain-Reaction â€” Cyber HUD Edition</title>
<style>
/* -------------------------------------------------------
   GLOBAL STYLE
-------------------------------------------------------*/
html, body {
  margin: 0;
  padding: 0;
  background: #020617;
  overflow: hidden;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
}
canvas { display: block; }

/* -------------------------------------------------------
   GLOSS OVERLAY (behind menu, over plane)
-------------------------------------------------------*/
#overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at center, rgba(15,23,42,0.3), rgba(15,23,42,0.9));
  backdrop-filter: blur(4px);
  z-index: 10;
}

/* -------------------------------------------------------
   START MENU UI (centered)
-------------------------------------------------------*/
#uiPanel {
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  padding: 20px 26px;
  background: rgba(0, 10, 40, 0.85);
  border: 1px solid rgba(0,255,255,0.45);
  border-radius: 14px;
  backdrop-filter: blur(8px);
  color: #e0f7ff;
  z-index: 20;
  font-size: 16px;
  box-shadow:
    0 0 20px rgba(0,255,255,0.25),
    0 30px 80px rgba(0,0,0,0.8);
  text-align: center;
  min-width: 280px;
}

#uiPanel h1 {
  margin: 0 0 8px;
  font-size: 22px;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: #7af0ff;
}
#uiPanel p {
  margin: 0 0 14px;
  font-size: 13px;
  color: #9cc9ff;
}

#uiPanel label {
  display: block;
  margin-bottom: 6px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #8be9ff;
}

#uiPanel input {
  width: 120px;
  padding: 6px 8px;
  font-size: 15px;
  margin-top: 2px;
  border-radius: 8px;
  border: 1px solid rgba(0,255,255,0.4);
  outline: none;
  background: rgba(15,23,42,0.9);
  color: #e5f6ff;
  text-align: center;
}
#uiPanel input:focus {
  box-shadow: 0 0 0 1px rgba(0,255,255,0.6);
}

#uiPanel button {
  margin-top: 16px;
  width: 100%;
  padding: 10px;
  font-size: 16px;
  border: none;
  border-radius: 10px;
  background: linear-gradient(90deg, #00eaff, #4f46e5);
  color: #0b1020;
  cursor: pointer;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  box-shadow: 0 0 18px rgba(0,234,255,0.35);
}
#uiPanel button:hover {
  filter: brightness(1.08);
}

/* small helper text */
#uiPanel .hint {
  margin-top: 10px;
  font-size: 11px;
  opacity: 0.7;
}

/* -------------------------------------------------------
   HIGHSCORE PANEL
-------------------------------------------------------*/
#highscorePanel {
  position: fixed;
  right: 12px;
  top: 10px;
  color: white;
  padding: 8px 14px;
  background: rgba(0, 20, 40, 0.2);
  border-radius: 8px;
  border: 1px solid rgba(0,255,255,0.2);
  font-size: 13px;
  pointer-events: none;
  white-space: nowrap;
  backdrop-filter: blur(3px);
  z-index: 25;
}

/* -------------------------------------------------------
   SMALL CYBER HUD (always visible after start)
-------------------------------------------------------*/
#hudSmall {
  position: fixed;
  left: 12px;
  top: 12px;
  padding: 10px 12px;
  background: rgba(0, 20, 40, 0.2);
  color: #b9e6ff;
  border: 1px solid rgba(0,255,255,0.25);
  border-radius: 10px;
  font-size: 13px;
  display: none;
  pointer-events: none;
  backdrop-filter: blur(4px);
  z-index: 30;
}
.hudGraph {
  width: 120px;
  height: 35px;
  background: rgba(0,255,255,0.05);
  border: 1px solid rgba(0,255,255,0.2);
  border-radius: 6px;
  margin-top: 6px;
}

/* -------------------------------------------------------
   DEV CONSOLE (hidden until "~" key)
-------------------------------------------------------*/
#devConsole {
  position: fixed;
  right: 0;
  top: 0;
  width: 340px;
  height: 100%;
  background: rgba(0, 10, 40, 0.86);
  border-left: 1px solid rgba(0,255,255,0.35);
  color: #b9e6ff;
  padding: 14px;
  box-sizing: border-box;
  display: none;
  overflow-y: auto;
  backdrop-filter: blur(6px);
  z-index: 40;
}

.consoleSectionTitle {
  font-size: 15px;
  margin-top: 14px;
  margin-bottom: 6px;
  color: #74f0ff;
  border-bottom: 1px solid rgba(0,255,255,0.2);
  padding-bottom: 4px;
}

/* log panel */
#logPanel {
  height: 180px;
  overflow-y: auto;
  background: rgba(0,255,255,0.05);
  border: 1px solid rgba(0,255,255,0.2);
  padding: 6px;
  border-radius: 6px;
  font-size: 12px;
}
.logEntry {
  margin-bottom: 4px;
  color: #d2faff;
}
</style>
</head>

<body>
<canvas id="c"></canvas>

<div id="overlay"></div>

<div id="uiPanel">
  <h1>Collision Chain-Reaction</h1>
  <p>Select how many balls to spawn, then unleash chaos.</p>

  <label for="ballCount">Starting Balls</label>
  <input type="number" id="ballCount" min="1" max="2000" value="20" />

  <button id="startBtn">Go</button>
  <div class="hint">Press ~ in-game to open the full Cyber Dev Console.</div>
</div>

<div id="hudSmall">
  <div id="hudText"></div>
  <canvas id="graphFPS" class="hudGraph"></canvas>
  <canvas id="graphCPU" class="hudGraph"></canvas>
  <canvas id="graphRAM" class="hudGraph"></canvas>
  <canvas id="graphSPAWN" class="hudGraph"></canvas>
</div>

<div id="devConsole">
  <div class="consoleSectionTitle">Performance</div>
  <div id="perfDetails"></div>

  <div class="consoleSectionTitle">Stress Score</div>
  <div id="stressPanel"></div>

  <div class="consoleSectionTitle">Logs</div>
  <div id="logPanel"></div>
</div>

<div id="highscorePanel"></div>

<script>
/* ============================================================================================
   UTILS
============================================================================================ */
function formatBig(n){
  if (n >= 1e9) return (n/1e9).toFixed(2) + "B";
  if (n >= 1e6) return (n/1e6).toFixed(2) + "M";
  if (n >= 1e3) return (n/1e3).toFixed(1) + "K";
  return String(n);
}

/* ============================================================================================
   CRASH-PERSISTENT HIGH SCORE SYSTEM
============================================================================================ */
function loadJSON(key, fallback) {
  try { return JSON.parse(localStorage.getItem(key)) || fallback; }
  catch { return fallback; }
}
let lastState = loadJSON("chainBalls_lastState", null);
let highScore = loadJSON("chainBalls_highScore", {
  maxBalls: 0, fps: 0, timestamp: null
});
const now = Date.now();
const CRASH_THRESHOLD_MS = 3000;
if (lastState && now - lastState.timestamp > CRASH_THRESHOLD_MS) {
  if (lastState.balls > highScore.maxBalls) {
    highScore = {
      maxBalls: lastState.balls,
      fps: lastState.fps,
      timestamp: new Date(lastState.timestamp).toLocaleString()
    };
    localStorage.setItem("chainBalls_highScore", JSON.stringify(highScore));
  }
}
// initial placeholder; will be updated every second by saveState()
localStorage.setItem("chainBalls_lastState", JSON.stringify({
  balls: 0, fps: 0, timestamp: Date.now()
}));

/* ============================================================================================
   CANVAS SETUP
============================================================================================ */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
resize(); addEventListener("resize", resize);

/* ============================================================================================
   BALL PHYSICS
============================================================================================ */
let INITIAL_BALLS = 20;
const BALL_RADIUS = 7;
const BASE_SPEED = 2.4;
const TRAIL_FADE = 0.15;
const SPAWN_COOLDOWN_FRAMES = 3;

const CELL_SIZE = BALL_RADIUS * 4;

function randRange(a,b){ return a + Math.random()*(b-a); }
function randomColor(){ return `hsl(${Math.random()*360},80%,60%)`; }

class Ball {
  constructor(x,y,vx,vy,r,color){
    this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.r=r;
    this.color=color; this.lastSpawnFrame=-9999;
  }
  update(){
    this.x+=this.vx; this.y+=this.vy;
    if(this.x-this.r<0){ this.x=this.r; this.vx*=-1; }
    else if(this.x+this.r>canvas.width){ this.x=canvas.width-this.r; this.vx*=-1; }
    if(this.y-this.r<0){ this.y=this.r; this.vy*=-1; }
    else if(this.y+this.r>canvas.height){ this.y=canvas.height-this.r; this.vy*=-1; }
  }
  draw(){
    ctx.fillStyle=this.color;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
    ctx.fill();
  }
}

let balls = [];
function createRandomBall(){
  const ang=Math.random()*Math.PI*2;
  const sp=randRange(BASE_SPEED*0.5,BASE_SPEED*1.5);
  return new Ball(
    randRange(BALL_RADIUS*4, canvas.width-BALL_RADIUS*4),
    randRange(BALL_RADIUS*4, canvas.height-BALL_RADIUS*4),
    Math.cos(ang)*sp,
    Math.sin(ang)*sp,
    BALL_RADIUS,
    randomColor()
  );
}
function spawnInitialBalls(count){
  balls = [];
  for(let i=0;i<count;i++) balls.push(createRandomBall());
}

/* ============================================================================================
   COLLISION (SPATIAL GRID)
============================================================================================ */
function distSq(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

let pairChecks = 0;
let actualCollisions = 0;

function cellKey(cx,cy){ return cx + "," + cy; }
let grid = new Map();

function resolveCollision(b1,b2){
  const dx=b2.x-b1.x, dy=b2.y-b1.y;
  const dist=Math.hypot(dx,dy)||1;
  const overlap=(b1.r+b2.r)-dist;
  if(overlap>0){
    const nx=dx/dist, ny=dy/dist;
    const half=overlap/2;
    b1.x-=nx*half; b1.y-=ny*half;
    b2.x+=nx*half; b2.y+=ny*half;

    const v1n=b1.vx*nx + b1.vy*ny;
    const v2n=b2.vx*nx + b2.vy*ny;
    const v1t=-b1.vx*ny + b1.vy*nx;
    const v2t=-b2.vx*ny + b2.vy*nx;

    const v1nA=v2n, v2nA=v1n;

    b1.vx = v1nA*nx - v1t*ny;
    b1.vy = v1nA*ny + v1t*nx;
    b2.vx = v2nA*nx - v2t*ny;
    b2.vy = v2nA*ny + v2t*nx;
  }
}

/* ============================================================================================
   PERFORMANCE TRACKING + STATE SAVE
============================================================================================ */
let frame = 0;
let lastFrameTimestamp = performance.now();
let dtLastFrame = 16.6;

let fps = 60;
let fpsFrameCount = 0;
let fpsLastUpdate = performance.now();
const FPS_UPDATE_INTERVAL = 500;

let lastBallCount = 0;
let lastBallUpdate = performance.now();
let spawnRate = 0;

const graphFPS = [];
const graphCPU = [];
const graphRAM = [];
const graphSPAWN = [];
const MAX_GRAPH_POINTS = 100;

function pushGraph(buffer, value){
  buffer.push(value);
  if(buffer.length>MAX_GRAPH_POINTS) buffer.shift();
}
function drawGraph(canvasEl, buffer, color){
  const g = canvasEl.getContext("2d");
  g.clearRect(0,0,canvasEl.width,canvasEl.height);
  g.strokeStyle = color;
  g.beginPath();
  const step = canvasEl.width / MAX_GRAPH_POINTS;
  buffer.forEach((v,i)=>{
    const x = i*step;
    const y = canvasEl.height - v*canvasEl.height;
    if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
  });
  g.stroke();
}

function getPerfStats(){
  const cpu = Math.min(1, Math.max(0, (dtLastFrame-16.6)/16.6));
  let usedRAM=null, totalRAM=null;
  if(performance.memory){
    usedRAM = performance.memory.usedJSHeapSize/(1024*1024);
    totalRAM = performance.memory.totalJSHeapSize/(1024*1024);
  }
  const now=performance.now();
  const dtBalls=(now-lastBallUpdate)/1000;
  if(dtBalls>=1){
    spawnRate = (balls.length-lastBallCount)/dtBalls;
    lastBallCount = balls.length;
    lastBallUpdate = now;
  }
  return {cpu, usedRAM, totalRAM};
}

// ðŸ” CRASH STATE SAVER â€“ this is what makes high score work
function saveState() {
  localStorage.setItem("chainBalls_lastState", JSON.stringify({
    balls: balls.length,
    fps: fps,
    timestamp: Date.now()
  }));
}
setInterval(saveState, 1000);

/* ============================================================================================
   DEV CONSOLE + LOGGING
============================================================================================ */
let devOpen = false;
document.addEventListener("keydown", e=>{
  if(e.key==="`" || e.key==="~"){
    devOpen = !devOpen;
    document.getElementById("devConsole").style.display = devOpen ? "block" : "none";
  }
});

function addLog(msg){
  const logPanel=document.getElementById("logPanel");
  const div=document.createElement("div");
  div.className="logEntry";
  div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
  logPanel.appendChild(div);
  while(logPanel.children.length>200) logPanel.removeChild(logPanel.children[0]);
  logPanel.scrollTop = logPanel.scrollHeight;
}

/* ============================================================================================
   SMALL HUD
============================================================================================ */
const hudSmall = document.getElementById("hudSmall");
const hudText = document.getElementById("hudText");
const graphCanvasFPS = document.getElementById("graphFPS");
const graphCanvasCPU = document.getElementById("graphCPU");
const graphCanvasRAM = document.getElementById("graphRAM");
const graphCanvasSPAWN = document.getElementById("graphSPAWN");
[graphCanvasFPS,graphCanvasCPU,graphCanvasRAM,graphCanvasSPAWN].forEach(g=>{
  g.width = 120;
  g.height = 35;
});

/* ============================================================================================
   MAIN LOOP
============================================================================================ */
function animate(timestamp){
  frame++;

  dtLastFrame = timestamp - lastFrameTimestamp;
  if(dtLastFrame <= 0) dtLastFrame = 0.0001;
  lastFrameTimestamp = timestamp;

  fpsFrameCount++;
  const elapsedForFps = timestamp - fpsLastUpdate;
  if (elapsedForFps >= FPS_UPDATE_INTERVAL) {
    fps = (fpsFrameCount * 1000) / elapsedForFps;
    fpsFrameCount = 0;
    fpsLastUpdate = timestamp;
  }

  requestAnimationFrame(animate);

  ctx.fillStyle = `rgba(2,6,23,${TRAIL_FADE})`;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  pairChecks = 0;
  actualCollisions = 0;

  for(const b of balls) b.update();

  grid.clear();
  for(const b of balls){
    const cx = (b.x / CELL_SIZE) | 0;
    const cy = (b.y / CELL_SIZE) | 0;
    const key = cellKey(cx,cy);
    let cell = grid.get(key);
    if(!cell){
      cell = { cx, cy, balls: [] };
      grid.set(key, cell);
    }
    cell.balls.push(b);
  }

  const rr = (BALL_RADIUS*2)**2;
  const neighborOffsets = [
    [0,0],
    [1,0],
    [0,1],
    [1,1],
    [-1,1]
  ];

  const newBalls = [];

  function processPair(b1,b2){
    if (b1 === b2) return;
    pairChecks++;
    if(distSq(b1,b2)<=rr){
      actualCollisions++;
      resolveCollision(b1,b2);
      if(frame>b1.lastSpawnFrame+SPAWN_COOLDOWN_FRAMES &&
         frame>b2.lastSpawnFrame+SPAWN_COOLDOWN_FRAMES){
        const dx=b2.x-b1.x, dy=b2.y-b1.y;
        const dist=Math.hypot(dx,dy)||1;
        const nx=dx/dist, ny=dy/dist;
        const spawnDist=BALL_RADIUS*1.3;
        const mx=b1.x+nx*spawnDist;
        const my=b1.y+ny*spawnDist;
        const angle=Math.random()*Math.PI*2;
        const speed=randRange(BASE_SPEED*2,BASE_SPEED*4);
        newBalls.push(new Ball(
          mx,my,
          Math.cos(angle)*speed,
          Math.sin(angle)*speed,
          BALL_RADIUS,
          randomColor()
        ));
        b1.lastSpawnFrame = frame;
        b2.lastSpawnFrame = frame;
      }
    }
  }

  for(const cell of grid.values()){
    const {cx, cy, balls: cellBalls} = cell;

    for(let i=0;i<cellBalls.length;i++){
      for(let j=i+1;j<cellBalls.length;j++){
        processPair(cellBalls[i], cellBalls[j]);
      }
    }

    for(const [ox,oy] of neighborOffsets){
      if(ox===0 && oy===0) continue;
      const nk = cellKey(cx+ox, cy+oy);
      const other = grid.get(nk);
      if(!other) continue;
      const otherBalls = other.balls;
      for(const b1 of cellBalls){
        for(const b2 of otherBalls){
          processPair(b1,b2);
        }
      }
    }
  }

  balls.push(...newBalls);
  for(const b of balls) b.draw();

  const stats = getPerfStats();
  const stress = Math.min(1000,
    balls.length*0.15 +
    pairChecks*0.0000001 +
    (1-Math.min(fps,60)/60)*200
  );

  hudText.innerHTML = `
    Balls: ${balls.length}<br>
    FPS: ${fps.toFixed(1)}<br>
    Frame: ${dtLastFrame.toFixed(2)} ms<br>
    CPU: ${(stats.cpu*100).toFixed(1)}%<br>
    Pair Checks: ${formatBig(pairChecks)}<br>
    Collisions: ${formatBig(actualCollisions)}<br>
    Spawn Rate: ${spawnRate.toFixed(1)}/s<br>
    RAM: ${
      stats.usedRAM ? stats.usedRAM.toFixed(1)+" / "+stats.totalRAM.toFixed(1)+" MB" : "N/A"
    }<br>
    Stress: ${stress.toFixed(0)}
  `;

  pushGraph(graphFPS, Math.min(1, fps/60));
  pushGraph(graphCPU, stats.cpu);
  pushGraph(graphRAM, stats.usedRAM ? Math.min(1,stats.usedRAM/stats.totalRAM) : 0);
  pushGraph(graphSPAWN, Math.min(1, spawnRate/200));

  drawGraph(graphCanvasFPS, graphFPS, "#00eaff");
  drawGraph(graphCanvasCPU, graphCPU, "#ff66cc");
  drawGraph(graphCanvasRAM, graphRAM, "#66ff99");
  drawGraph(graphCanvasSPAWN, graphSPAWN, "#ffaa44");

  if(devOpen){
    document.getElementById("perfDetails").innerHTML = `
      FPS (avg ${FPS_UPDATE_INTERVAL}ms): ${fps.toFixed(1)}<br>
      Frame Time (last): ${dtLastFrame.toFixed(2)} ms<br>
      CPU Load (est): ${(stats.cpu*100).toFixed(1)}%<br>
      RAM Used: ${
        stats.usedRAM ? stats.usedRAM.toFixed(2)+" MB" : "N/A"
      }<br>
      RAM Total: ${
        stats.totalRAM ? stats.totalRAM.toFixed(1)+" MB" : "N/A"
      }<br>
      Balls: ${balls.length}<br>
      Pair Checks (last frame): ${formatBig(pairChecks)}<br>
      Collisions (last frame): ${formatBig(actualCollisions)}<br>
      Spawns/sec: ${spawnRate.toFixed(1)}
    `;
    document.getElementById("stressPanel").innerHTML =
      `Stress Score: <b>${stress.toFixed(0)}</b>`;
  }

  document.getElementById("highscorePanel").innerHTML =
    `High Score: <b>${highScore.maxBalls}</b><br>
     FPS at Crash: <b>${highScore.fps.toFixed(1)}</b><br>
     When: ${highScore.timestamp || "â€”"}`;
}

/* ============================================================================================
   START BUTTON HANDLING
============================================================================================ */
const overlay = document.getElementById("overlay");

document.getElementById("startBtn").onclick = ()=>{
  INITIAL_BALLS = Math.max(1, Math.min(2000,
    Number(document.getElementById("ballCount").value)
  ));
  spawnInitialBalls(INITIAL_BALLS);

  hudSmall.style.display = "block";
  document.getElementById("uiPanel").style.display = "none";
  overlay.style.display = "none";

  addLog("Simulation started with "+INITIAL_BALLS+" balls.");
};

requestAnimationFrame(animate);
</script>
</body>
</html>
