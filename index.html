<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Collision Chain-Reaction — Cyber HUD Edition</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  background: #020617;
  overflow: hidden;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
}
canvas { display: block; }

#overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at center, rgba(15,23,42,0.3), rgba(15,23,42,0.9));
  backdrop-filter: blur(4px);
  z-index: 10;
}

#uiPanel {
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  padding: 20px 26px;
  background: rgba(0, 10, 40, 0.85);
  border: 1px solid rgba(0,255,255,0.45);
  border-radius: 14px;
  backdrop-filter: blur(8px);
  color: #e0f7ff;
  z-index: 20;
  font-size: 16px;
  box-shadow:
    0 0 20px rgba(0,255,255,0.25),
    0 30px 80px rgba(0,0,0,0.8);
  text-align: center;
  min-width: 280px;
}
#uiPanel h1 {
  margin: 0 0 8px;
  font-size: 22px;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: #7af0ff;
}
#uiPanel p {
  margin: 0 0 14px;
  font-size: 13px;
  color: #9cc9ff;
}
#uiPanel label {
  display: block;
  margin-bottom: 6px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #8be9ff;
}
#uiPanel input {
  width: 120px;
  padding: 6px 8px;
  font-size: 15px;
  margin-top: 2px;
  border-radius: 8px;
  border: 1px solid rgba(0,255,255,0.4);
  outline: none;
  background: rgba(15,23,42,0.9);
  color: #e5f6ff;
  text-align: center;
}
#uiPanel input:focus {
  box-shadow: 0 0 0 1px rgba(0,255,255,0.6);
}
#uiPanel button {
  margin-top: 16px;
  width: 100%;
  padding: 10px;
  font-size: 16px;
  border: none;
  border-radius: 10px;
  background: linear-gradient(90deg, #00eaff, #4f46e5);
  color: #0b1020;
  cursor: pointer;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  box-shadow: 0 0 18px rgba(0,234,255,0.35);
}
#uiPanel button:hover { filter: brightness(1.08); }
#uiPanel .hint {
  margin-top: 10px;
  font-size: 11px;
  opacity: 0.7;
}

#highscorePanel {
  position: fixed;
  right: 12px;
  top: 10px;
  color: white;
  padding: 8px 14px;
  background: rgba(0, 20, 40, 0.2);
  border-radius: 8px;
  border: 1px solid rgba(0,255,255,0.2);
  font-size: 13px;
  pointer-events: none;
  white-space: nowrap;
  backdrop-filter: blur(3px);
  z-index: 25;
}

#hudSmall {
  position: fixed;
  left: 12px;
  top: 12px;
  padding: 10px 12px;
  background: rgba(0, 20, 40, 0.2);
  color: #b9e6ff;
  border: 1px solid rgba(0,255,255,0.25);
  border-radius: 10px;
  font-size: 13px;
  display: none;
  pointer-events: none;
  backdrop-filter: blur(4px);
  z-index: 30;
}
.hudGraph {
  width: 120px;
  height: 35px;
  background: rgba(0,255,255,0.05);
  border: 1px solid rgba(0,255,255,0.2);
  border-radius: 6px;
  margin-top: 6px;
}

#devConsole {
  position: fixed;
  right: 0;
  top: 0;
  width: 340px;
  height: 100%;
  background: rgba(0, 10, 40, 0.86);
  border-left: 1px solid rgba(0,255,255,0.35);
  color: #b9e6ff;
  padding: 14px;
  box-sizing: border-box;
  display: none;
  overflow-y: auto;
  backdrop-filter: blur(6px);
  z-index: 40;
}
.consoleSectionTitle {
  font-size: 15px;
  margin-top: 14px;
  margin-bottom: 6px;
  color: #74f0ff;
  border-bottom: 1px solid rgba(0,255,255,0.2);
  padding-bottom: 4px;
}
#logPanel {
  height: 180px;
  overflow-y: auto;
  background: rgba(0,255,255,0.05);
  border: 1px solid rgba(0,255,255,0.2);
  padding: 6px;
  border-radius: 6px;
  font-size: 12px;
}
.logEntry {
  margin-bottom: 4px;
  color: #d2faff;
}

/* dev console controls */
.controlRow {
  margin: 6px 0;
}
.controlBtn {
  padding: 4px 8px;
  margin: 2px 4px 2px 0;
  font-size: 12px;
  border-radius: 6px;
  border: 1px solid rgba(0,255,255,0.3);
  background: rgba(0,30,60,0.8);
  color: #d9f7ff;
  cursor: pointer;
}
.controlBtn:hover {
  background: rgba(0,255,255,0.12);
}
#timeScaleLabel {
  font-weight: 600;
  color: #7af0ff;
}
</style>
</head>

<body>
<canvas id="c"></canvas>

<div id="overlay"></div>

<div id="uiPanel">
  <h1>Collision Chain-Reaction</h1>
  <p>Select how many balls to spawn, then unleash chaos.</p>
  <label for="ballCount">Starting Balls</label>
  <input type="number" id="ballCount" min="1" max="2000" value="20" />
  <button id="startBtn">Go</button>
  <div class="hint">Press ~ in-game to open the full Cyber Dev Console.</div>
</div>

<div id="hudSmall">
  <div id="hudText"></div>
  <canvas id="graphFPS" class="hudGraph"></canvas>
  <canvas id="graphCPU" class="hudGraph"></canvas>
  <canvas id="graphRAM" class="hudGraph"></canvas>
  <canvas id="graphSPAWN" class="hudGraph"></canvas>
</div>

<div id="devConsole">
  <div class="consoleSectionTitle">Performance</div>
  <div id="perfDetails"></div>

  <div class="consoleSectionTitle">Controls</div>
  <div id="controlsPanel">
    <div>Time Scale: <span id="timeScaleLabel">1.0x</span></div>
    <div class="controlRow">
      <button class="controlBtn speedBtn" data-speed="0.25">0.25×</button>
      <button class="controlBtn speedBtn" data-speed="0.5">0.5×</button>
      <button class="controlBtn speedBtn" data-speed="1">1×</button>
      <button class="controlBtn speedBtn" data-speed="2">2×</button>
      <button class="controlBtn speedBtn" data-speed="4">4×</button>
      <button class="controlBtn" id="btnPause">Pause</button>
    </div>
    <div class="controlRow">
      <button class="controlBtn" id="btnRestart">Restart Run</button>
      <button class="controlBtn" id="btnHalf">Despawn 50%</button>
      <button class="controlBtn" id="btnNuke">Despawn 90%</button>
    </div>
    <div class="controlRow">
      <button class="controlBtn" id="btnAdd1">Add 1</button>
      <button class="controlBtn" id="btnAdd5">Add 5</button>
      <button class="controlBtn" id="btnAdd10">Add 10</button>
    </div>
  </div>

  <div class="consoleSectionTitle">Stress Score</div>
  <div id="stressPanel"></div>

  <div class="consoleSectionTitle">Logs</div>
  <div id="logPanel"></div>
</div>

<div id="highscorePanel"></div>

<script>
function formatBig(n){
  if (n >= 1e9) return (n/1e9).toFixed(2) + "B";
  if (n >= 1e6) return (n/1e6).toFixed(2) + "M";
  if (n >= 1e3) return (n/1e3).toFixed(1) + "K";
  return String(n);
}

function loadJSON(key, fallback) {
  try { return JSON.parse(localStorage.getItem(key)) || fallback; }
  catch { return fallback; }
}

// ----- High score + last-state -----
let lastState = loadJSON("chainBalls_lastState", null);
let highScore = loadJSON("chainBalls_highScore", {
  maxBalls: 0,
  fps: 0,
  timestamp: null
});

if (lastState && typeof lastState.balls === "number" && lastState.balls > highScore.maxBalls) {
  highScore = {
    maxBalls: lastState.balls,
    fps: lastState.fps || 0,
    timestamp: lastState.timestamp ? new Date(lastState.timestamp).toLocaleString() : null
  };
  localStorage.setItem("chainBalls_highScore", JSON.stringify(highScore));
}

localStorage.setItem("chainBalls_lastState", JSON.stringify({
  balls: 0, fps: 0, timestamp: Date.now()
}));

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let canvasArea = 1;
function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  canvasArea = canvas.width * canvas.height;
}
resize();
addEventListener("resize", resize);

let INITIAL_BALLS = 20;
const BALL_RADIUS = 7;
const BASE_SPEED = 2.4;
const TRAIL_FADE = 0.15;
const SPAWN_COOLDOWN_FRAMES = 3;
const CELL_SIZE = BALL_RADIUS * 4;
const CIRCLE_AREA = Math.PI * BALL_RADIUS * BALL_RADIUS;

let trailsDisabled = false;
const TRAIL_COVERAGE_THRESHOLD = 0.9;
let lastCoverageCheckFrame = 0;

// time scaling / pause
let timeScale = 1;
let isPaused = false;
let lastNonZeroScale = 1;

// achievement tracking
const ACHIEVEMENT_THRESHOLDS = [
  10,
  100,
  1000,
  10000,
  100000,
  1000000,
  10000000
];
let unlockedAchievements = new Set();
let simStartTime = null;

function formatElapsed(ms){
  const totalSec = Math.floor(ms / 1000);
  const mins = Math.floor(totalSec / 60);
  const secs = totalSec % 60;
  return `${mins}:${secs.toString().padStart(2,"0")}`;
}

function randRange(a,b){ return a + Math.random()*(b-a); }
function randomColor(){ return `hsl(${Math.random()*360},80%,60%)`; }

class Ball {
  constructor(x,y,vx,vy,r,color){
    this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.r=r;
    this.color=color; this.lastSpawnFrame=-9999;
  }
  update(){
    const s = timeScale;
    this.x += this.vx * s;
    this.y += this.vy * s;
    if(this.x-this.r<0){ this.x=this.r; this.vx*=-1; }
    else if(this.x+this.r>canvas.width){ this.x=canvas.width-this.r; this.vx*=-1; }
    if(this.y-this.r<0){ this.y=this.r; this.vy*=-1; }
    else if(this.y+this.r>canvas.height){ this.y=canvas.height-this.r; this.vy*=-1; }
  }
  draw(){
    ctx.fillStyle=this.color;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
    ctx.fill();
  }
}

let balls = [];
function createRandomBall(){
  const ang=Math.random()*Math.PI*2;
  const sp=randRange(BASE_SPEED*0.5,BASE_SPEED*1.5);
  return new Ball(
    randRange(BALL_RADIUS*4, canvas.width-BALL_RADIUS*4),
    randRange(BALL_RADIUS*4, canvas.height-BALL_RADIUS*4),
    Math.cos(ang)*sp,
    Math.sin(ang)*sp,
    BALL_RADIUS,
    randomColor()
  );
}
function spawnInitialBalls(count){
  balls = [];
  trailsDisabled = false;
  lastCoverageCheckFrame = 0;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let i=0;i<count;i++) balls.push(createRandomBall());
}

function distSq(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

let pairChecks = 0;
let actualCollisions = 0;
function cellKey(cx,cy){ return cx + "," + cy; }
let grid = new Map();

function resolveCollision(b1,b2){
  const dx=b2.x-b1.x, dy=b2.y-b1.y;
  const dist=Math.hypot(dx,dy)||1;
  const overlap=(b1.r+b2.r)-dist;
  if(overlap>0){
    const nx=dx/dist, ny=dy/dist;
    const half=overlap/2;
    b1.x-=nx*half; b1.y-=ny*half;
    b2.x+=nx*half; b2.y+=ny*half;

    const v1n=b1.vx*nx + b1.vy*ny;
    const v2n=b2.vx*nx + b2.vy*ny;
    const v1t=-b1.vx*ny + b1.vy*nx;
    const v2t=-b2.vx*ny + b2.vy*nx;

    const v1nA=v2n, v2nA=v1n;
    b1.vx = v1nA*nx - v1t*ny;
    b1.vy = v1nA*ny + v1t*nx;
    b2.vx = v2nA*nx - v2t*ny;
    b2.vy = v2nA*ny + v2t*nx;
  }
}

let frame = 0;
let lastFrameTimestamp = performance.now();
let dtLastFrame = 16.6;

let fps = 60;
let fpsFrameCount = 0;
let fpsLastUpdate = performance.now();
const FPS_UPDATE_INTERVAL = 500;

let lastBallCount = 0;
let lastBallUpdate = performance.now();
let spawnRate = 0;

const graphFPS = [];
const graphCPU = [];
const graphRAM = [];
const graphSPAWN = [];
const MAX_GRAPH_POINTS = 100;

function pushGraph(buffer, value){
  buffer.push(value);
  if(buffer.length>MAX_GRAPH_POINTS) buffer.shift();
}
function drawGraph(canvasEl, buffer, color){
  const g = canvasEl.getContext("2d");
  g.clearRect(0,0,canvasEl.width,canvasEl.height);
  g.strokeStyle = color;
  g.beginPath();
  const step = canvasEl.width / MAX_GRAPH_POINTS;
  buffer.forEach((v,i)=>{
    const x = i*step;
    const y = canvasEl.height - v*canvasEl.height;
    if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
  });
  g.stroke();
}

function getPerfStats(){
  const cpu = Math.min(1, Math.max(0, (dtLastFrame-16.6)/16.6));
  let usedRAM=null, totalRAM=null;
  if(performance.memory){
    usedRAM = performance.memory.usedJSHeapSize/(1024*1024);
    totalRAM = performance.memory.totalJSHeapSize/(1024*1024);
  }
  const now=performance.now();
  const dtBalls=(now-lastBallUpdate)/1000;
  if(dtBalls>=1){
    spawnRate = (balls.length-lastBallCount)/dtBalls;
    lastBallCount = balls.length;
    lastBallUpdate = now;
  }
  return {cpu, usedRAM, totalRAM};
}

function saveState() {
  localStorage.setItem("chainBalls_lastState", JSON.stringify({
    balls: balls.length,
    fps: fps,
    timestamp: Date.now()
  }));
}
setInterval(saveState, 1000);

let devOpen = false;
document.addEventListener("keydown", e=>{
  if(e.key==="`" || e.key==="~"){
    devOpen = !devOpen;
    document.getElementById("devConsole").style.display = devOpen ? "block" : "none";
  }
});

function addLog(msg){
  const logPanel=document.getElementById("logPanel");
  const div=document.createElement("div");
  div.className="logEntry";
  div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
  logPanel.appendChild(div);
  while(logPanel.children.length>200) logPanel.removeChild(logPanel.children[0]);
  logPanel.scrollTop = logPanel.scrollHeight;
}

// HUD + graphs
const hudSmall = document.getElementById("hudSmall");
const hudText = document.getElementById("hudText");
const graphCanvasFPS = document.getElementById("graphFPS");
const graphCanvasCPU = document.getElementById("graphCPU");
const graphCanvasRAM = document.getElementById("graphRAM");
const graphCanvasSPAWN = document.getElementById("graphSPAWN");
[graphCanvasFPS,graphCanvasCPU,graphCanvasRAM,graphCanvasSPAWN].forEach(g=>{
  g.width = 120;
  g.height = 35;
});

// dev controls elements
const timeScaleLabel = document.getElementById("timeScaleLabel");
document.querySelectorAll(".speedBtn").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    const s = parseFloat(btn.getAttribute("data-speed"));
    timeScale = s;
    isPaused = false;
    lastNonZeroScale = s;
    timeScaleLabel.textContent = s.toFixed(2).replace(/\.00$/,"") + "x";
    addLog("Time scale set to " + s + "x");
  });
});

// pause button
document.getElementById("btnPause").addEventListener("click", ()=>{
  if (!isPaused) {
    if (timeScale > 0) lastNonZeroScale = timeScale;
    timeScale = 0;
    isPaused = true;
    timeScaleLabel.textContent = "Paused";
    addLog("Simulation paused");
  } else {
    timeScale = lastNonZeroScale || 1;
    isPaused = false;
    timeScaleLabel.textContent = timeScale.toFixed(2).replace(/\.00$/,"") + "x";
    addLog("Simulation resumed at " + timeScale + "x");
  }
});

document.getElementById("btnRestart").addEventListener("click", ()=>{
  spawnInitialBalls(INITIAL_BALLS);
  unlockedAchievements.clear();
  simStartTime = Date.now();
  addLog("Run restarted with " + INITIAL_BALLS + " balls.");
});

// helper: keep random subset of balls
function keepRandomFraction(fraction){
  const old = balls.length;
  if (old === 0) return;
  let keep = Math.floor(old * fraction);
  if (keep < 1 && old > 0) keep = 1;

  for (let i = 0; i < keep; i++) {
    const j = i + Math.floor(Math.random() * (old - i));
    const tmp = balls[i];
    balls[i] = balls[j];
    balls[j] = tmp;
  }
  balls.length = keep;

  trailsDisabled = false;
  lastCoverageCheckFrame = frame;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  addLog(`Despawned ${(100 - fraction*100).toFixed(0)}% of balls: ${old} → ${balls.length}`);
}

document.getElementById("btnHalf").addEventListener("click", ()=>{
  keepRandomFraction(0.5);
});

document.getElementById("btnNuke").addEventListener("click", ()=>{
  keepRandomFraction(0.1);
});

// add-balls helper + buttons
function addBalls(count){
  for(let i=0;i<count;i++){
    balls.push(createRandomBall());
  }
  addLog("Added " + count + " ball" + (count===1 ? "" : "s") +
         " (total: " + balls.length + ")");
}
document.getElementById("btnAdd1").addEventListener("click", ()=>addBalls(1));
document.getElementById("btnAdd5").addEventListener("click", ()=>addBalls(5));
document.getElementById("btnAdd10").addEventListener("click", ()=>addBalls(10));

// achievement check
function checkAchievements(){
  if (simStartTime == null) return;
  const now = Date.now();
  for (const th of ACHIEVEMENT_THRESHOLDS) {
    if (!unlockedAchievements.has(th) && balls.length >= th) {
      unlockedAchievements.add(th);
      const elapsed = formatElapsed(now - simStartTime);
      addLog(`${elapsed} after start - ${th.toLocaleString()} balls reached`);
    }
  }
}

function animate(timestamp){
  frame++;

  dtLastFrame = timestamp - lastFrameTimestamp;
  if(dtLastFrame <= 0) dtLastFrame = 0.0001;
  lastFrameTimestamp = timestamp;

  fpsFrameCount++;
  const elapsedForFps = timestamp - fpsLastUpdate;
  if (elapsedForFps >= FPS_UPDATE_INTERVAL) {
    fps = (fpsFrameCount * 1000) / elapsedForFps;
    fpsFrameCount = 0;
    fpsLastUpdate = timestamp;
  }

  requestAnimationFrame(animate);

  if (!trailsDisabled) {
    ctx.fillStyle = `rgba(2,6,23,${TRAIL_FADE})`;
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  pairChecks = 0;
  actualCollisions = 0;

  if (!isPaused) {
    // physics + collisions + spawning only when not paused
    for(const b of balls) b.update();

    grid.clear();
    for(const b of balls){
      const cx = (b.x / CELL_SIZE) | 0;
      const cy = (b.y / CELL_SIZE) | 0;
      const key = cellKey(cx,cy);
      let cell = grid.get(key);
      if(!cell){
        cell = { cx, cy, balls: [] };
        grid.set(key, cell);
      }
      cell.balls.push(b);
    }

    const rr = (BALL_RADIUS*2)**2;
    const neighborOffsets = [
      [0,0],
      [1,0],
      [0,1],
      [1,1],
      [-1,1]
    ];

    const newBalls = [];
    function processPair(b1,b2){
      if (b1 === b2) return;
      pairChecks++;
      if(distSq(b1,b2)<=rr){
        actualCollisions++;
        resolveCollision(b1,b2);
        if(frame>b1.lastSpawnFrame+SPAWN_COOLDOWN_FRAMES &&
           frame>b2.lastSpawnFrame+SPAWN_COOLDOWN_FRAMES){
          const dx=b2.x-b1.x, dy=b2.y-b1.y;
          const dist=Math.hypot(dx,dy)||1;
          const nx=dx/dist, ny=dy/dist;
          const spawnDist=BALL_RADIUS*1.3;
          const mx=b1.x+nx*spawnDist;
          const my=b1.y+ny*spawnDist;
          const angle=Math.random()*Math.PI*2;
          const speed=randRange(BASE_SPEED*2,BASE_SPEED*4);
          newBalls.push(new Ball(
            mx,my,
            Math.cos(angle)*speed,
            Math.sin(angle)*speed,
            BALL_RADIUS,
            randomColor()
          ));
          b1.lastSpawnFrame = frame;
          b2.lastSpawnFrame = frame;
        }
      }
    }

    for(const cell of grid.values()){
      const {cx, cy, balls: cellBalls} = cell;

      for(let i=0;i<cellBalls.length;i++){
        for(let j=i+1;j<cellBalls.length;j++){
          processPair(cellBalls[i], cellBalls[j]);
        }
      }

      for(const [ox,oy] of neighborOffsets){
        if(ox===0 && oy===0) continue;
        const nk = cellKey(cx+ox, cy+oy);
        const other = grid.get(nk);
        if(!other) continue;
        const otherBalls = other.balls;
        for(const b1 of cellBalls){
          for(const b2 of otherBalls){
            processPair(b1,b2);
          }
        }
      }
    }

    balls.push(...newBalls);

    // coverage → kill trails
    if (!trailsDisabled && frame - lastCoverageCheckFrame >= 15 && canvasArea > 0) {
      lastCoverageCheckFrame = frame;
      const coverage = (balls.length * CIRCLE_AREA) / canvasArea;
      if (coverage >= TRAIL_COVERAGE_THRESHOLD) {
        trailsDisabled = true;
        addLog("Trails disabled: coverage ≈ " + (coverage*100).toFixed(1) + "%");
      }
    }

    // live high score
    if (balls.length > highScore.maxBalls) {
      highScore.maxBalls = balls.length;
      highScore.fps = fps;
      highScore.timestamp = new Date().toLocaleString();
      localStorage.setItem("chainBalls_highScore", JSON.stringify(highScore));
    }

    // achievements (only progress when actually simulating)
    checkAchievements();
  }

  // draw always (so the frozen scene still shows while paused)
  for(const b of balls) b.draw();

  const stats = getPerfStats();
  const stress = Math.min(1000,
    balls.length*0.15 +
    pairChecks*0.0000001 +
    (1-Math.min(fps,60)/60)*200
  );

  const timeLabel = isPaused
    ? "Paused"
    : timeScale.toFixed(2) + "x";

  hudText.innerHTML = `
    Balls: ${balls.length}<br>
    FPS: ${fps.toFixed(1)}<br>
    Frame: ${dtLastFrame.toFixed(2)} ms<br>
    CPU: ${(stats.cpu*100).toFixed(1)}%<br>
    Pair Checks: ${formatBig(pairChecks)}<br>
    Collisions: ${formatBig(actualCollisions)}<br>
    Spawn Rate: ${spawnRate.toFixed(1)}/s<br>
    Time Scale: ${timeLabel}<br>
    Trails: ${trailsDisabled ? "OFF" : "ON"}<br>
    RAM: ${
      stats.usedRAM ? stats.usedRAM.toFixed(1)+" / "+stats.totalRAM.toFixed(1)+" MB" : "N/A"
    }<br>
    Stress: ${stress.toFixed(0)}
  `;

  pushGraph(graphFPS, Math.min(1, fps/60));
  pushGraph(graphCPU, stats.cpu);
  pushGraph(graphRAM, stats.usedRAM ? Math.min(1,stats.usedRAM/stats.totalRAM) : 0);
  pushGraph(graphSPAWN, Math.min(1, spawnRate/200));

  drawGraph(graphCanvasFPS, graphFPS, "#00eaff");
  drawGraph(graphCanvasCPU, graphCPU, "#ff66cc");
  drawGraph(graphCanvasRAM, graphRAM, "#66ff99");
  drawGraph(graphCanvasSPAWN, graphSPAWN, "#ffaa44");

  if(devOpen){
    document.getElementById("perfDetails").innerHTML = `
      FPS (avg ${FPS_UPDATE_INTERVAL}ms): ${fps.toFixed(1)}<br>
      Frame Time (last): ${dtLastFrame.toFixed(2)} ms<br>
      CPU Load (est): ${(stats.cpu*100).toFixed(1)}%<br>
      RAM Used: ${
        stats.usedRAM ? stats.usedRAM.toFixed(2)+" MB" : "N/A"
      }<br>
      RAM Total: ${
        stats.totalRAM ? stats.totalRAM.toFixed(1)+" MB" : "N/A"
      }<br>
      Balls: ${balls.length}<br>
      Pair Checks (last frame): ${formatBig(pairChecks)}<br>
      Collisions (last frame): ${formatBig(actualCollisions)}<br>
      Spawns/sec: ${spawnRate.toFixed(1)}<br>
      Time Scale: ${timeLabel}<br>
      Trails: ${trailsDisabled ? "OFF" : "ON"}
    `;
    document.getElementById("stressPanel").innerHTML =
      `Stress Score: <b>${stress.toFixed(0)}</b>`;
  }

  document.getElementById("highscorePanel").innerHTML =
    `High Score: <b>${highScore.maxBalls}</b><br>
     FPS at Peak: <b>${highScore.fps.toFixed(1)}</b><br>
     When: ${highScore.timestamp || "—"}`;
}

const overlay = document.getElementById("overlay");
document.getElementById("startBtn").onclick = ()=>{
  INITIAL_BALLS = Math.max(1, Math.min(2000,
    Number(document.getElementById("ballCount").value)
  ));
  spawnInitialBalls(INITIAL_BALLS);
  unlockedAchievements.clear();
  simStartTime = Date.now();
  hudSmall.style.display = "block";
  document.getElementById("uiPanel").style.display = "none";
  overlay.style.display = "none";
  addLog("Simulation started with "+INITIAL_BALLS+" balls.");
};

requestAnimationFrame(animate);
</script>
</body>
</html>
